import { Canvas, Meta, Source, Title } from '@storybook/addon-docs/blocks';

import Docs from '@/dev/docBlocks';
import { ControlledValue } from '@/dev/stories/ControlledValue';

import { Aside } from '@/components/Aside';

import { Money } from './Money';
import * as stories from './Money.stories';

<Meta of={stories} name="How it works" />

# How the <Docs of="Money" /> component works ü§ì

<Docs.TableOfContents />

## Observations and ideas

I wanted to build a currency input component that was delightful to use for both
the user & the developer, so I started by thinking about what would I would need
to solve for.

### Currency inputs are used in high-impact situations

... relative to other form controls.

Whether you‚Äôre filling out a banking form (withdrawal, transfer, wire, ...),
e-commerce form (pricing backend, tipping), HR form (salaries, paycheck
deductions...), or in a forecasting tool‚Äîentering the wrong amount just once can
lead to major headaches, reputational damage, or even prison time! Therefore,
this component has a role to play in getting the user into an accuracy mindset.

### Currency formatting is very helpful, and snazzy!

<div className="sb-unstyled sm:float-right sm:mt-3 sm:mb-3 sm:ml-6 sm:max-w-75">
  <Aside sizer="sm">
    <Aside.Paragraph children="Currency symbols are so cool. Just look at these guys!" />
    <Aside.Paragraph
      className="text-lg font-bold tracking-widest"
      children="‡∏ø ¬£ ∆í ‚Ç© ¬• ‚Ç° ‚Ç± ‚Ç¨ ‚Ç´ ‚Çº ·üõ"
    />
  </Aside>
</div>

- Currency symbols are very effective at hinting that the field is monetary and
  important.

- ‚ÄúThousands separators‚Äù (e.g. commas) are helpful for comprehending larger
  numbers. They may also be the difference between submitting a devestatingly
  wrong amount, and fixing it first. If I ever see a comma while I‚Äôm entering a
  tip amount, I‚Äôll be on high alert!

- As an American, numbers presented in the European format can be confusing.
  `1.234,56` is üòØ, `4,56` is ü§®, and `1.234` is üò∞‚Äîis that a ‚Äúone thousand two
  hundred thirty four‚Äù or have they pre-converted it for me as ‚Äúone point two
  three four‚Äù? I have to imagine that users across cultures have similar
  experiences, so presenting the appropriate currency format is both a
  friendlier user experience, and more likely to produce accurate values.

- I like input placeholders a lot; they‚Äôre like the ‚Äúself-documenting code‚Äù of
  form controls. And anytime I see a number with two decimal places, especially
  when padded with trailing zeros (which are unnecessary in most other
  situations), I‚Äôm likely to interpret it as a currency amount. So showing
  `0.00` as a placeholder in a US$ currency input (or `0.00000000` for ‚Çøitcoin)
  is another opportunity to create some intuition about the field type &
  importance.

### Reformatting the value _as you‚Äôre typing_ is disorienting

I‚Äôve used currency inputs that automatically add the thousands separators as you
type. In my opinion, this is better than not adding them at all, for the reasons
outlined above. But if you type with any kind of speed, the visual chaos can
cause you to lose your train of thought.

- By default, the browser will automatically move the cursor to the end of the
  input value whenever it is programatically changed (such as to slot in
  thousands separators). This means that if you add a digit to the middle of the
  number, your cursor may be yanked over to the end of the number.

- _You can_ programatically reposition the cursor into the right place after
  programatically updating the value, but even if you get it right, it‚Äôs still
  chaotic: the existing commas can flop around (`1,234,567|.00` ->
  `12,345,678|.00`), and the addition/removal of commas causes the cursor to
  shift by an unexpected amount. Components that attempt to do this are often
  easy to break, since there are so many of edge cases. I initially went down
  this path, and while I felt I had a bulletproof implementation, it still
  wasn‚Äôt a good user experience (& now I had a ton of gritty code to maintain).

### Preventing invalid input is helpful‚Äîto an extent

For accessibility & usability purposes (and to reduce the amount of code I have
to write), I always build off of the appropriate native elements, but the
`<input type="number">` control does not display commas. So I'd have to drop
down to using an `<input type="text">`, and then layer on my own logic for
blocking non-numerical input. Obviously, I can block letters (unless, for
example, the user is holding `command` while typing `c` to copy the value).
Beyond that, as a user of forms, my experience is that having my keystrokes
blocked is frustrating unless I'm expecting it, since it‚Äôs unclear whether it‚Äôs
blocked on purpose, or if my browser is malfunctioning.

- Blocking a second decimal point is probably ok since it‚Äôs reasonable to expect
  that it‚Äôs not allowed.
- Negative signs can be restricted to the first character.
- Blocking keystrokes based on having a minimum / maximum value for the field is
  not ideal. For example, if field has a maximum allowed value of `1000`, and
  the current value is `999`, I could theoretically block adding an additional
  non-decimal digit, since that would push the value over `1000`. However, I
  don‚Äôt think there is a sufficiently good way to pre-educate the user on an
  allowed numeric range before they start typing, since they generally don‚Äôt
  read fine print. As a result, I‚Äôve opted-out of having min/max options, and
  recommend presenting error messages to the user when they go outside of an
  allowed range.
- With one exception: in most situations, I think the concept of "negative
  money" is not intuitive. For example, if you have a withdrawal form, you‚Äôll
  probably ask the user to a enter a ‚Äúpositive amount to withdraw‚Äù, rather than
  a ‚Äúnegative amount to add to your account.‚Äù So <Docs of="Money" /> blocks
  negatives by default, but offers an option to allow them.

### Currency formatting is tedious

In order to be as useful as possible for developers, the component should
consider how data arrives at its front door, and where it‚Äôs going / how it‚Äôll be
used when exiting via the `onChange` handler. As a developer who worked on this
component, I know that the work of formatting, and deformatting, especially when
the currency format might be "dynamic" within your application if you serve
users in different countries, is really tiresome. So the component should handle
it all for you!

If you‚Äôre pre-filling the field with a `value` (or `defaultValue`), you should
be able to just "pass through" the data you get from any of these sources
without any intervention:

- a database (where it‚Äôs probably stored as a `float` or `decimal` type, and may
  be `null` if it‚Äôs an optional column)

- a JSON response from some API, where it‚Äôll be a `string` or `number`, and if
  unset, will be `null` or an empty `string`.

- some hardcoded value in your javascript codebase, where it may also be
  `undefined`.

When the user changes the value, there is a very high probability that you will
need to deformat it before storing it or using it within javascript. So the
component should deformat the new value before passing it back.

- As far as I know, most databases do not internationalize their data types.
  Values with thousands separators or a character other than "." for the decimal
  point are rejected by numeric table columns.

- Within javascript, you might want to perform some calculation off of the new
  value, so you‚Äôll need to parse it as a `Number()`. While a French user will
  intuitively understand `1.234,56` as a number, javascript won‚Äôt.

NickUI provides a `formatMoney` function for the case where you _do_ want to
have a value formatted in the same way the <Docs of="Money" /> component would.

## Architecture

### Formatting options

In my experience, good frontend architecting often starts with a high-level
breakdown of the system into its major sub-components, and getting very
meticulous about their props, prop types, and TSDocs. It‚Äôs a good way to hone in
on the ideal ‚Äúseparation of concerns‚Äù, and after a few iterations, you‚Äôll have a
solid starting high-level architecture you (or another engineer) can attack.

For this component, my hunch was that the key decision was going to be around
how the currency formatting options made their way around the system, and how
changes to them or the value would impact calls to `onChange`, as well as render
cycles & visual jank.

After the thought exercise above, I landed on the following format object type.
Each piece arrives as a separate prop, so the component has a flatter prop API,
but they‚Äôre combined internally into a standard object before cascading through
the sub-components, hooks, and utility functions. The object is _always_ named
`format` & has the same type, which makes the code predictable & traceable. And
it‚Äôs made stable via memoization at the top, so the system as a whole can care
less about render cycles.

Instead of breaking these out into separate options, I could have taken a single
prop like `currencyType: 'usd' | 'eur' | ...`, but then my component would have
to know every existing (& imaginary) currency format out there, and it would be
far less flexible.

The component uses US$ defaults, since I might as well make the formatting props
unnecessary for some developers!

```ts
/** The <Money> component‚Äôs formatting-related props */
type MoneyFormatType = {
  /** The currency symbol shown at the front of the input, typically "$" */
  currencySymbol: React.ReactNode;
  /**
   * The character separating the whole part from the decimal part, typically
   * "." Needs to be a string rather than ReactNode, since it will be included
   * within the input value.
   */
  decimalPoint: string;
  /**
   * The character to use to separate every three digits in the whole part,
   * typically ",". Needs to be a string rather than ReactNode, since it will
   * be included within the input value.
   */
  thousandsSeparator: string;
  /**
   * Constraints for the number of digits to the right of the decimal point.
   * - the component will suggest adding the `min` w/ an omnipresent placeholder
   * - the value emitted via `onChange` always has at least the `min` (unless
   *   empty)
   * - the user can never add more than the `max`
   */
  decimalPlaces: { min: number; max: number };
  /** Set to `true` to allow the user to enter negative values */
  allowNegatives: boolean;
};
```

### Three separate `<input>` elements

When you interact with the <Docs of="Money" /> component, you‚Äôre actually
interacting with one of three `<input>` elements. In addition to the interactive
("working") input, there are two others: one shows the placeholder value, and
the other is normally hidden & actually drives the form behavior.

Normally, they are collapsed together via overlapping & hiding, so you (& the
screen reader) perceive a single control. This demo shows the three inputs
separated out.

<ControlledValue defaultValue="">
  {(value, setValue) => (
    <div className="sb-unstyled flex flex-col sm:flex-row sm:items-stretch sm:gap-4">
      <div className="flex-1">
        <Docs.FauxCanvas>
          <Money
            label="Separated out"
            hint={
              <>
                <div>top: placeholder input</div>
                <div>middle: working input (overlaps the placholder)</div>
                <div>bottom: form input (hidden)</div>
              </>
            }
            value={value}
            onChange={(event) => setValue(event.target.value)}
            docsMeta={{ spread: true }}
            allowNegatives
          />
        </Docs.FauxCanvas>
      </div>
      <div className="-mt-10 flex-1 sm:mt-0">
        <Docs.FauxCanvas>
          <Money
            label="Collapsed together"
            value={value}
            onChange={(event) => setValue(event.target.value)}
            allowNegatives
          />
        </Docs.FauxCanvas>
      </div>
    </div>
  )}
</ControlledValue>

#### The working `<input>`

Obviously, there needs to be an `<input>` that the user interacts with to modify
the field‚Äôs value. And to support showing commas in its value, it needs to be an
`<input type="text">`. In my system, I call this the **"working input"** (where
the user works on the value). The user needs to be able to be "working towards"
typing out a valid monetary value, so it allows temporarily trailing decimal
points, temporarily lone negative signs, and temporarily fewer than the required
decimal places.

#### The form `<input>`

There is a second, hidden `<input>` which I call the **"form input"**. It is
what form libraries attach to (via the `ref`, `name`, `onChange`, `onBlur` etc.
props).

I don‚Äôt want the `onChange` callback to fire unless there is a _numerical_
change to the value. For example, if I progammatically update the value to
add/remove/adjust the commas, I don‚Äôt think that `<Money>`‚Äôs parent should be
concerned with that change‚Äîit really only cares when there is a new
monetarily/numerically different value. For the parent‚Äôs intents & purposes (&
performance), situations like these should be considered equivalent:

- `1`, `1.`, `1.0`, and `1.00` (the parent is only notified on the initial
  keystroke in that sequence)
- `1234` (before I progmatically add the comma) & `1,234` (after)

Note: ‚Äúunset‚Äù should be different than zero, so while `0`, `0.`, `0.0`, `-0.0`,
etc. are all equivalent, they are considered a change from when the value is
empty, and vice versa.

Rather than having a single `<input>` where I "intercept" changes and choose
when to block them vs. propogate them up to the parent, it‚Äôs better to just have
a separate, hidden `<input>` which only tracks the numerical representation of
the current value. When there is a _numerical_ change to the working input, I
progammatically trigger an `'input'` event to the form input, which causes its
`onChange` handler to fire with the numerically-parseable form of the value. For
example, if the working input receives `"1.234,56"`, the form input‚Äôs onChange
handler will fire with `"1234.56"`.

This is particularly important for making the component compatible with the
various current & future form libraries out there, since they set values &
observe changes in different ways. We don‚Äôt want those libraries overwriting our
formatting, and we only want them to pay attention to numerical changes.

#### The placeholder `<input>`

Finally, there is a third `<input>` I call the **"placeholder input"**, which is
responsible for showing the placeholder value. I concluded earlier that always
showing the full number of available decimal places is important, so in addition
to showing a placeholder like `0.00` when the field is empty, we also want to
show the remaining available decimal places as zeros as the user is filling the
field out.

Normally, you can just use the `placeholder` attribute to do this for you, like
`<input placeholder="0.00">`. However, as soon as you start typing, it won‚Äôt
show the placeholder at all, which doesn‚Äôt allow us to show the remaining
decimal places. So my solution was to have this separate input that is placed
directly _behind_ the working input. It uses the same styles, and I‚Äôve "cloned"
the scroll position of one to the other using a
[custom hook I built](https://github.com/NickDunkman/nickui/blob/main/src/components/Money/Money.tsx#L45),
so the text is always precisely aligned, and you only see the trailing zeros.

### Value state reducer

This component has some pretty complex requirements:

- At any given moment, there are several formats used by the sub-elements, which
  need to be in sync with eachother
- There are several ways to update the value, each with their own nuance for how
  they should update those different formatted instances (for example, we have
  to be careful about how we cascade changes from an updated controlled `value`
  prop, so that we don‚Äôt clobber the user‚Äôs work)
- There are several "effects" that occur when the value changes. For example, in
  some instances the cursor positioning needs to be adjusted.

To avoid having the internal implentation absolutely explode in complexity, it‚Äôs
crucial that any changes to the state happen _within a single render cycle_. Not
only does this prevent visual jank, it also helps make sure we only call the
`onChange` once when the value changes.

Thankfully, `React.useReducer` offers a great way to make complex state changes
as a single change. The reducer I wrote (wrapped in `useValueStateReducer()`)
offers these actions:

- **`UPDATE_FROM_CONTROLLED_VALUE`**: used when the component receives an update
  to its `value` prop.
- **`UPDATE_FROM_WORKING_VALUE`**: used when the user changes the value of the
  interactive "working" `<input>`
- **`UPDATE_FORMAT`**: used when the formatting props change, such as when
  switching currencies
- **`INCREMENT_VALUE`**: used to increment/decrement the value by some number.
  For example, pressing `ArrowUp` increments by 1; `Shift+ArrowUp` increments
  by 10.
- **`SET_WORKING_MODE`**: used when the component is focused, to remove
  thousands separators & allow partial values in the working input
- **`SET_IDLE_MODE`**: used when the component is burred, to add thousands
  separators back & snap any partial input into a full monetary value
- **`REINITIALIZE_WITH_VALUE`**: Updates the value & resets the change history.
  React Hook Form sets the initial value of its fields by changing the value
  _after_ the component is mounted, and we want to use that value without
  behaving like it is a change.

If you peak into the component <Docs.SourceLink
path="/blob/main/src/components/Money/Money.tsx" />, you‚Äôll see that all of this
complex state stuff is encapsulated into hooks; the component function itself is
almost entirely JSX & presentational logic. The chain of hook calls looks like:

- `useValueStateReducer` uses `React.useReducer` to create a "value state" store
- `useValueState` wraps `useValueStateReducer` to simplify interaction with the
  store
- `useValueElementsProps` encapsulates all of that and provides props for all of
  the sub-elements that depend on the value state (such as to display the value,
  or make changes).
- `Money` calls `useValueElementsProps` and spreads the props within its JSX
