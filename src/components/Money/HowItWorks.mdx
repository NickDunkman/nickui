import { Canvas, Meta, Source, Title } from '@storybook/addon-docs/blocks';

import Docs from '@/dev/docBlocks';
import { ControlledValue } from '@/dev/stories/ControlledValue';

import { Aside } from '@/components/Aside';

import { Money } from './Money';
import * as stories from './Money.stories';

<Meta of={stories} name="How it works" />

# How the <Docs of="Money" /> component works ü§ì

<Docs.TableOfContents />

## Observations and ideas

I wanted to build a currency input component that was delightful to use for both
the user & the developer, so I started by thinking about what would I would need
to solve for.

### Currency inputs are used in high-impact situations

... relative to other form controls.

Whether you‚Äôre filling out a banking form (withdrawal, transfer, wire, ...),
e-commerce form (pricing backend, tipping), HR form (salaries, paycheck
deductions...), or in a forecasting tool‚Äîentering the wrong amount just once can
lead to major headaches, reputational damage, or even prison time! Therefore,
this component has a role to play in getting the user focused and in preventing
mistakes.

### Currency formatting is very helpful, and snazzy!

<div className="sb-unstyled sm:float-right sm:mt-3 sm:mb-3 sm:ml-6 sm:max-w-75">
  <Aside sizer="sm">
    <Aside.Paragraph children="Currency symbols are so cool. Just look at these guys!" />
    <Aside.Paragraph
      className="text-lg font-bold tracking-widest"
      children="‡∏ø ¬£ ∆í ‚Ç© ¬• ‚Ç° ‚Ç± ‚Ç¨ ‚Ç´ ‚Çº ·üõ"
    />
  </Aside>
</div>

- Currency symbols are very effective at hinting that the field is monetary and
  important.

- ‚ÄúThousands separators‚Äù (e.g. commas) are helpful for comprehending larger
  numbers. They may also be the difference between submitting a devestatingly
  wrong amount, and fixing it first. If I ever see a comma while I‚Äôm entering a
  tip amount, I‚Äôll be on high alert!

- As an American, numbers presented in the European format can be confusing.
  `1.234,56` is üòØ, `4,56` is ü§®, and `1.234` is üò∞‚Äîis that a ‚Äúone thousand two
  hundred thirty four‚Äù or have they pre-converted it for me as ‚Äúone point two
  three four‚Äù? I have to imagine that users across cultures have similar
  experiences, so presenting the appropriate currency format is both a
  friendlier user experience, and more likely to produce accurate values.

- I like input placeholders a lot; they‚Äôre like the ‚Äúself-documenting code‚Äù of
  form controls. And anytime I see a number with two decimal places, especially
  when padded with trailing zeros (which are unnecessary in most other
  situations), I‚Äôm likely to interpret it as a currency amount. So showing
  `0.00` as a placeholder in a US$ currency input (or `0.00000000` for ‚Çøitcoin)
  is another opportunity to create some intuition about the field type &
  importance.

### Reformatting the value _as you‚Äôre typing_ is disorienting

I‚Äôve used currency inputs that automatically add the thousands separators _as
you type_. In my opinion, this is better than not adding them at all, for the
reasons outlined above, but if you type with any kind of speed, it feels so
chaotic that it can become befuddling!

- By default, the browser will automatically move the cursor to the end of the
  input value whenever it is programatically changed (such as to slot in
  thousands separators). This means that if you add a digit to the middle of the
  number, your cursor may be yanked over to the end of the number.

- _You can_ programatically reposition the cursor into the right place after
  programatically updating the value, but even if you get it right, it‚Äôs still
  chaotic: the existing commas can flop around (`1,234,567|.00` ->
  `12,345,678|.00`), and the addition/removal of commas causes the cursor to
  shift by an unexpected amount. And now you‚Äôve got a _ton_ of gritty code to
  maintain, because there are many, many edge cases. I went down this path, but
  it still wasn‚Äôt a good user experience after I solved every possible edge
  case.

### Preventing invalid input is helpful‚Äîto an extent

For accessibility & usability purposes (and to reduce the amount of code I have
to write), I always build off of the appropriate native elements, but the
`<input type="number">` control does not display commas. So I'd have to drop
down to using an `<input type="text">`, and then layer on my own logic for
blocking non-numerical input. Obviously, I can block letters (unless, for
example, the user is holding `command` while typing `c` to copy the value).
Beyond that, as a user of forms, my experience is that having my keystrokes
blocked is frustrating unless I'm expecting it, since it‚Äôs unclear whether it‚Äôs
blocked on purpose, or if my browser is malfunctioning.

- Blocking a second decimal point is probably ok since it‚Äôs reasonable to expect
  that it‚Äôs not allowed.
- Negative signs can be restricted to the first character.
- Blocking keystrokes based on having a minimum / maximum value for the field is
  not ideal. For example, if field has a maximum allowed value of `1000`, and
  the current value is `999`, I could theoretically block adding an additional
  non-decimal digit, since that would push the value over `1000`. However, I
  don‚Äôt think there is a sufficiently good way to pre-educate the user on an
  allowed numeric range before they start typing, since they generally don‚Äôt
  read fine print. As a result, I‚Äôve opted-out of having min/max options, and
  recommend presenting error messages to the user when they go outside of an
  allowed range.
- With one exception: in most situations, I think the concept of "negative
  money" is not intuitive. For example, if you have a withdrawal form, you‚Äôll
  probably ask the user to a enter a ‚Äúpositive amount to withdraw‚Äù, rather than
  a ‚Äúnegative amount to add to your account.‚Äù So <Docs of="Money" /> blocks
  negatives by default, but offers an option to allow them.

### Currency formatting is tedious

In order to be as useful as possible for developers, the component should
consider how data arrives at its front door, and where it‚Äôs going / how it‚Äôll be
used when exiting via the `onChange` handler. As a developer who worked on this
component, I know that the work of formatting, and deformatting, especially when
the currency format might be "dynamic" within your application if you serve
users in different countries, is really tiresome. So the component should handle
it all for you!

If you‚Äôre pre-filling the field with a `value` (or `defaultValue`), you should
be able to just "pass through" the data you get from any of these sources
without any intervention:

- a database (where it‚Äôs probably stored as a `float` or `decimal` type, and may
  be `null` if it‚Äôs an optional column)

- a JSON response from some API, where it‚Äôll be a `string` or `number`, and if
  unset, will be `null` or an empty `string`.

- some hardcoded value in your javascript codebase, where it may also be
  `undefined`.

When the user changes the value, there is a very high probability that you will
need to deformat it before storing it or using it within javascript. So the
component should deformat the new value before passing it back.

- As far as I know, most databases do not internationalize their data types.
  Values with thousands separators or a character other than "." for the decimal
  point are rejected by numeric table columns.

- Within javascript, you might want to perform some calculation off of the new
  value, so you‚Äôll need to parse it as a `Number()`. While a French user will
  intuitively understand `1.234,56` as a number, javascript won‚Äôt.

NickUI provides a `formatMoney` function for the case where you _do_ want to
have a value formatted in the same way the <Docs of="Money" /> component would.

## Architecture

### Formatting options

After concluding the thought exercise outlined above, these are the options I
landed on supporting.

Instead of breaking these out into separate options, I could have taken a single
prop like `currencyType: 'usd' | 'eur' | ...`, but then my component would have
to know every existing (& imaginary) currency format out there, and it would be
far less flexible.

I used US$ defaults for these (+ disallowing negatives), since I might as well
make these props unnecessary for some developers!

```ts
/** The <Money> component‚Äôs formatting-related props */
type MoneyFormatProps = {
  /** The currency symbol shown at the front of the input, typically "$" */
  currencySymbol?: React.ReactNode;
  /**
   * The character separating the whole part from the decimal part, typically
   * "." Needs to be a string rather than ReactNode, since it will be included
   * within the input value.
   */
  decimalPoint?: string;
  /**
   * The character to use to separate every three digits in the whole part,
   * typically ",". Needs to be a string rather than ReactNode, since it will
   * be included within the input value.
   */
  thousandsSeparator?: string;
  /**
   * Controls how many decimal places the user is allowed to add, and how many
   * will always be included on the value emitted via the onChange handler.
   * Typically 2.
   */
  decimalPlaces?: number;
  /** Set to `true` to allow the user to enter negative values */
  allowNegatives?: boolean;
};
```

There are many moving parts within the system which depend on some subset of the
formatting options, & lots of complex re-rendering patterns. So to make the code
simpler, more predictable, & more performant, I wrapped the options into a
standard object type that I could memoize at the top layer & then drill down
through the various utilities & hooks.

Additionally, there is a little more nuance to the formatting options used
_internally_. For example, sometimes I need to allow the user to be "working
towards" typing the full number of decimal places, and other times, I need to
display the value w/ all of the decimal places ‚Äúpadded on‚Äù.

```ts
/**
 * The standard format object <Money> drills down through its children &
 * grandchildren
 */
type MoneyFormatType = Required<Omit<MoneyFormatType, 'decimalPlaces'>> & {
  minDecimalPlaces: number;
  maxDecimalPlaces: number;
  /**
   * Whether to allow the string to have a trailing decimal point, which is
   * necessary on the input the user is typing in, since you have to type a
   * decimal point before you can type the decimal places. But the value ejected
   * via the onChange handler should never have a trailing decimal point.
   */
  allowWorkingDecimalPoint?: boolean;
  /**
   * Whether to all the negative sign to exist on its own. Necessary for the
   * input the user is typing in, since often, the user will type the negative
   * sign first before typing the rest of the negative number. However, the
   * value ejected via the onChange handler should never just be "-".
   */
  allowWorkingNegativeSign?: boolean;
};
```

### Three separate `<input>` elements

When you interact with the <Docs of="Money" /> component, you‚Äôre actually
interacting with one of three `<input>` elements. In addition to the interactive
("working") input, there are two others: one shows the placeholder value, and
the other is normally hidden & actually drives the form behavior.

Normally, they are collapsed together via overlapping & hiding, so you (& the
screen reader) perceive a single control. This demo shows the three inputs
separated out.

<ControlledValue defaultValue="">
  {(value, setValue) => (
    <div className="sb-unstyled flex flex-col sm:flex-row sm:items-stretch sm:gap-4">
      <div className="flex-1">
        <Docs.FauxCanvas>
          <Money
            label="Separated out"
            hint={
              <>
                <div>top: placeholder input</div>
                <div>middle: working input (overlaps the placholder)</div>
                <div>bottom: form input (hidden)</div>
              </>
            }
            value={value}
            onChange={(event) => setValue(event.target.value)}
            docsMeta={{ spread: true }}
            allowNegatives
          />
        </Docs.FauxCanvas>
      </div>
      <div className="-mt-10 flex-1 sm:mt-0">
        <Docs.FauxCanvas>
          <Money
            label="Collapsed together"
            value={value}
            onChange={(event) => setValue(event.target.value)}
            allowNegatives
          />
        </Docs.FauxCanvas>
      </div>
    </div>
  )}
</ControlledValue>

#### The working `<input>`

Obviously, there needs to be an `<input>` that the user interacts with to modify
the field‚Äôs value. And to support showing commas in its value, it needs to be an
`<input type="text">`. In my system, I call this the **"working input"** (where
the user works on the value). The user needs to be able to be "working towards"
typing out a valid monetary value, so it allows temporarily trailing decimal
points, temporarily lone negative signs, and temporarily fewer than the required
decimal places.

#### The form `<input>`

There is a second, hidden `<input>` which I call the **"form input"**. It is
what form libraries attach to (via the `ref`, `name`, `onChange`, `onBlur` etc.
props).

I don‚Äôt want the `onChange` callback to fire unless there is a _numerical_
change to the value. For example, if I progammatically update the value to
add/remove/adjust the commas, I don‚Äôt think that `<Money>`‚Äôs parent should be
concerned with that change‚Äîit really only cares when there is a new
monetarily/numerically different value. For the parent‚Äôs intents & purposes (&
performance), situations like these should be considered equivalent:

- `1`, `1.`, `1.0`, and `1.00` (the parent is only notified on the initial
  keystroke in that sequence)
- `1234` (before I progmatically add the comma) & `1,234` (after)

Note: ‚Äúunset‚Äù should be different than zero, so while `0`, `0.`, `0.0`, `-0.0`,
etc. are all equivalent, they are considered a change from when the value is
empty, and vice versa.

Rather than having a single `<input>` where I "intercept" changes and choose
when to block them vs. propogate them up to the parent, it‚Äôs better to just have
a separate, hidden `<input>` which only tracks the numerical representation of
the current value. When there is a _numerical_ change to the working input, I
progammatically trigger an `'input'` event to the form input, which causes its
`onChange` handler to fire with the numerically-parseable form of the value. For
example, if the working input receives `"1.234,56"`, the form input‚Äôs onChange
handler will fire with `"1234.56"`.

This is particularly important for making the component compatible with the
various current & future form libraries out there, since they set values &
observe changes in different ways. We don‚Äôt want those libraries overwriting our
formatting, and we only want them to pay attention to numerical changes.

#### The placeholder `<input>`

Finally, there is a third `<input>` I call the **"placeholder input"**, which is
responsible for showing the placeholder value. I concluded earlier that always
showing the full number of available decimal places is important, so in addition
to showing a placeholder like `0.00` when the field is empty, we also want to
show the remaining available decimal places as zeros as the user is filling the
field out.

Normally, you can just use the `placeholder` attribute to do this for you, like
`<input placeholder="0.00">`. However, as soon as you start typing, it won‚Äôt
show the placeholder at all, which doesn‚Äôt allow us to show the remaining
decimal places. So my solution was to have this separate input that is placed
directly _behind_ the working input. It uses the same styles, and I‚Äôve "cloned"
the scroll position of one to the other using a
[custom hook I built](https://github.com/NickDunkman/nickui/blob/main/src/components/Money/Money.tsx#L45),
so the text is always precisely aligned, and you only see the trailing zeros.

### Value state reducer

The internal "value state" of this component is very complex, especially when
you consider the many ways the value might be updated, and the nuanced changes
each update method has on the state.

At any given time, the component needs to track all of these pieces, and they
need to be in sync with eachother to prevent inconsistent state and duplicate
calls to the `onChange` handler:

- the "controlled value" received from the parent component via the `value`
  prop, so the component knows whether a change came from that prop.
- the "working value" for the working input, which is formatted & can be
  incomplete
- the "placeholder value" for the placeholder input, which is formatted and
  should have the complete number of decimal places
- the "form value" for the form input, which is _not formatted_ and must be
  parseable as a javascript number (or empty).
- the formatting options that were present when all of the above formatting
  occurred, in case we need to perform operations on these numbers in later
  render cycles.
- a enum representation of what source of the lastest mutation was

And each of the ways the value might be updated can cascade changes to these
different pieces in different ways!

- When the controlled `value` prop changes & it‚Äôs _numerically_ different from
  our current value, we should update all variations of the value
- The controlled `value` prop can also change as a result of us calling the
  `onChange` handler, which shouldn‚Äôt clobber the working input‚Äôs "partial
  value" progress.
- When the working input value changes, we update the formatted variations, and
  trigger a form value update if there is a numerical change.
- When incrementing using the up/down arrows, there is different logic for
  keeping the cursor in the right place.
- etc. etc. etc.

Luckily, `React.useReducer` was created to make sense of situations like this.
If you peak into the implementation of <Docs of="Money" />, you‚Äôll find a hook
call chain which ultimately relies on `React.useReducer` to manage a versioned
history of changes to the value.

- `useValueStateReducer()` uses `React.useReducer` to manage a "value state"
  object
- `useValueState()` wraps `useValueStateReducer` and adds some functions for
  making changes
- `useValueElementsProps()` encapsulates all of that and provides props for all
  of the sub-elements that depend on the value state (such as to display the
  value, or make changes).
