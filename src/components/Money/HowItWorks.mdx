import { Canvas, Meta, Source, Title } from '@storybook/addon-docs/blocks';

import Docs from '@/dev/docBlocks';

import { Aside } from '@/components/Aside';

import { Money } from './Money';
import * as stories from './Money.stories';

<Meta of={stories} name="How it works" />

<Docs.ComponentHeading of="Money" subtitle="How it works" />

_The <Docs of="Money" /> component is a bit of a beast, so I figured I'd
document the thinking that went into it._

<br />

<Title>How it works</Title>

I wanted to build a currency input component that was delightful to use for both
the user & the developer, so I started from a few observations & ideas:

- **Currency inputs are often involved in high-impact use cases relative to
  other types of form controls.** Whether you‚Äôre filling out a banking form
  (withdrawal, transfer, wire, ...), e-commerce form (pricing backend, tipping),
  HR form (salaries, paycheck deductions...), or in a forecasting tool‚Äîentering
  the wrong amount just once can lead to major headaches, reputational damage,
  or even prison time! Therefore, this component has a role to play in getting
  the user focused and in preventing mistakes.

<div className="sb-unstyled ml-4 sm:float-right sm:mb-3 sm:ml-6 sm:max-w-75">
  <Aside sizer="sm">
    <Aside.Paragraph children="Currency symbols are so cool. Just look at these guys!" />
    <Aside.Paragraph
      className="text-lg font-bold tracking-widest"
      children="‡∏ø ¬£ ∆í ‚Ç© ¬• ‚Ç° ‚Ç± ‚Ç¨ ‚Ç´ ‚Çº ·üõ"
    />
  </Aside>
</div>

- **Currency formatting & internationalization is very helpful, and snazzy!**
  - Currency symbols are very effective at hinting that the field is monetary
    and important.
  - ‚ÄúThousands separators‚Äù (e.g. commas) are helpful for comprehending larger
    numbers. They may also be the difference between submitting a devestatingly
    wrong amount, and fixing it first. If I ever see a comma while I‚Äôm entering
    a tip amount, I‚Äôll be on high alert!
  - As an American, numbers presented in the European format can be confusing.
    `1.234,56` is üòØ, `4,56` is ü§®, and `1.234` is üò∞‚Äîis that a ‚Äúone thousand
    two hundred thirty four‚Äù or have they pre-converted it for me as ‚Äúone point
    two three four‚Äù? I have to imagine that users across cultures have similar
    experiences, so presenting the appropriate currency format is both a
    friendlier user experience, and more likely to produce accurate values.
  - I like input placeholders a lot; they‚Äôre like the ‚Äúself-documenting code‚Äù of
    form controls. And anytime I see a number with two decimal places,
    especially when padded with trailing zeros (which are unnecessary in most
    other situations), I‚Äôm likely to interpret it as a currency amount. So
    showing `0.00` as a placeholder in a US$ currency input (or `0.00000000` for
    ‚Çøitcoin) is another opportunity to create some intuition about the field
    type & importance.

- **_Reformatting_ the value as you type is disorienting.** I‚Äôve used currency
  inputs that automatically add the thousands separators _as you type_. In my
  opinion, this is better than not adding them at all, for the reasons outlined
  above, but if you type with any kind of speed, it feels so chaotic that it can
  become _befuddling_!
  - By default, the browser will automatically move the cursor to the end of the
    input value whenever it is programatically changed (such as to slot in
    thousands separators). This means that if you add a digit to the middle of
    the number, your cursor may be yanked over to the end of the number.
  - _You can_ programatically reposition the cursor into the right place after
    programatically updating the value, but even if you get it right, it‚Äôs still
    chaotic: the existing commas can flop around (`1,234,567|.00` ->
    `12,345,678|.00`), and the addition/removal of commas causes the cursor to
    shift by an unexpected amount. And now you‚Äôve got a _ton_ of gritty code to
    maintain, because there are many, many edge cases. I went down this path,
    but it still wasn‚Äôt a good user experience after I solved every possible
    edge case.

- **Preventing invalid input is helpful‚Äîto an extent.** For accessibility &
  usability purposes (and to reduce the amount of code I have to write), I
  always build off of the appropriate native elements, but the
  `<input type="number">` control does not display commas. So I'd have to drop
  down to using an `<input type="text">`, and then layer on my own logic for
  blocking non-numerical input. Obviously, I can block letters (unless, for
  example, the user is holding `command` while typing `c` to copy the value).
  Beyond that, as a user of forms, my experience is that having my keystrokes
  blocked is frustrating unless I'm expecting it, since it‚Äôs unclear whether
  it‚Äôs blocked on purpose, or if my browser has frozen.
  - Blocking a second decimal point is probably ok since it‚Äôs reasonable to
    expect that it‚Äôs not allowed.
  - Negative signs can be restricted to the first character.
  - Blocking keystrokes based on having a minimum / maximum value for the field
    is not ideal. For example, if field has a maximum allowed value of `1000`,
    and the current value is `999`, we could theoretically block adding an
    additional non-decimal digit, since that would put the value at over `1000`.
    However, I don‚Äôt think there is a sufficiently good way to pre-educate the
    user on an allowed numeric range before they start typing, since they
    generally don‚Äôt read fine print. As a result, I‚Äôve opted-out of having
    min/max options, and recommend presenting error messages to the user when
    they go outside of an allowed range.
  - With one exception: in most situations, I think the concept of "negative
    money" is not intuitive. For example, if you have a withdrawal form, you‚Äôll
    probably ask the user to a enter a ‚Äúpositive amount to withdraw‚Äù, rather
    than a ‚Äúnegative amount to add to your account.‚Äù So <Docs of="Money" />
    blocks negatives by default, but offers an option to allow them.

- **Programatically formatting & deformatting is tedious.** In order to be as
  useful as possible for developers, the component should consider how data
  arrives at its front door, and where it‚Äôs going / how it‚Äôll be used when
  exiting via the `onChange` handler. As a developer who worked on this
  component, I know that the work of formatting, and deformatting, especially
  when the currency format might be "dynamic" within your application if you
  serve users in different countries, is really tiresome. So the component
  should handle it all for you!
  - If you‚Äôre pre-filling the field with a `value` (or `defaultValue`), you
    should be able to just "pass through" the data you get from any of these
    sources, without having to transform it first:
    - a database (where it‚Äôs probably stored as a `number` or `currency` type,
      and may be `null` if it‚Äôs an optional column)
    - a JSON response from some API, where it‚Äôll be a `string` | `number`, and
      if unset, will be `null` or an empty `string`.
    - some hardcoded value in your javascript codebase, where it may also be
      `undefined`.
  - When the user changes the value, there is a very high probability that you
    will need to de-format it before storing it or using it within javascript.
    So the component should pass the pre-de-format the new value before passing
    it back.
    - As far as I know, most databases do not internationalize their data types.
      Numbers with thousands separators or a character other than "." for the
      decimal point is rejected.
    - Within javascript, you might want to perform some calculation off of the
      new value, so you‚Äôll need to parse it as a `Number()`. While a French user
      will intuitively understand `1.234,56` as a number, javascript won‚Äôt.
    - NickUI provides a `formatMoney` function for the case where you _do_ want
      to have a value formatted in the same way the <Docs of="Money" />
      component would.
